require "stringio"

if ARGV.length != 2
  # TODO: allow for I/O via standard I/O (pipes)
  puts "usage: ruby dynare_fixer.rb INPUT_FILE OUTPUT_FILE"
  exit
end

# replaces a function with the arguments passed in
#  - command: the command to do the substitution in
#  - name: the name of the function
#  - args: the argument list
#  - expression: the expression of the function
def args_replace command, name, args, expression
  initial_offset = offset = (command =~ /\b#{Regexp.escape name}\(/) + name.length + 1
  bracket_count = 1

  # find the last bracket
  while offset < command.length
    if command[offset] == ?(
      bracket_count += 1
    elsif command[offset] == ?)
      bracket_count -= 1
      break if bracket_count == 0
    end

    offset += 1
  end

  args_expr = command[initial_offset..(offset - 1)].split(",").map(&:strip)

  # passed the wrong number of arguments to this function
  if args_expr.length != args.length
    raise Exception.new("Error: wrong number of arguments for call to #{name} in command '#{command}'")
  end

  # do the substitutions
  command[0..(initial_offset - name.length - 2)] + "(" + args.zip(args_expr).inject(expression) do |result, (find, repl)|
    result.gsub(/\b#{Regexp.escape find}\b/, "(" + repl + ")")
  end + ")" + command[(offset + 1)..-1]
end

defines = []
output_lines = []

input_commands = []

# First, we need to parse out the individual commands and the comments
input = StringIO.new File.read(ARGV[0])
buffer = StringIO.new

state = :begin

input.each_char do |c|
  # 3 states:
  # - not in a comment
  # - almost a comment (for comments using //)
  # - in a comment
  case state
  when :begin
    if c == "/"
      state = :comment?
    elsif c == "%"
      state = :comment
    elsif c == ";"
      input_commands << buffer.string + ";"
      buffer.string = ""
    else
      buffer.putc c
    end
  when :comment?
    if c == "/"
      state = :comment
      input_commands << buffer.string
      buffer.string = ""
      buffer.print "//"
    else
      state = :begin
      buffer.print "/" + c
    end
  when :comment
    if c == "\n"
      state = :begin
      input_commands << buffer.string + "\n"
      buffer.string = ""
    else
      buffer.putc c
    end
  end
end

input_commands << buffer.string

output_lines << "// Auto-generated by Dynare Fixer\n"

# now check each command to see if it is a function definition,
# until we get to the model block. Once we're in the model block,
# start replacing function calls with their corresponding expressions
state = :start
input_commands.each do |cmd|
  case state
  when :start
    if cmd =~ /def\s+([\w\d]+)\((.*?)\)\s*=\s*(.*);\s*/
      expr = $3
      defines << [$1, $2.split(/\s*,\s*/), expr]
      output_lines << cmd.sub("def", "//def")
    elsif cmd =~ /^\s*model\s*;/
      state = :model
      output_lines << cmd
    else
      output_lines << cmd
    end
  when :model
    if cmd =~ /end/
      state = :done
    else
      defines.each do |name, args, expression|
        while cmd =~ /\b#{Regexp.escape name}\(/
          cmd = args_replace(cmd, name, args, expression)
        end
      end
    end

    output_lines << cmd
  else
    output_lines << cmd
  end
end

# dump to a file
File.open(ARGV[1], "w") do |output|
  output.write output_lines.join
end
